---
sidebar_position: 1
---

# Integrating Raidflux

:::tip
If at any point you need help implementing Raidflux into your game, feel free to contact us at support@raidflux.com or take a look at our example project at [Raidflux Demo Game](https://github.com/Raidflux/raidflux-unreal-engine-demo)
:::

:::important
Right now, it's not possible to use Raidflux with a Blueprint only project because our plugin requires you to compile C++. You can convert this quite easily by creating a new C++ project and simply copying over your content.
:::

## Dedicated server build target

First, you will have to add the dedicated server build target. To add your dedicated server build target, follow the instructions as listed here: https://docs.unrealengine.com/4.26/en-US/InteractiveExperiences/Networking/HowTo/DedicatedServers/

The last thing left to do now is to change the target of the game to the Client type. Open the default target for your game as shown below and change the type from ```TargetType.Game``` to ```TargetType.Client```

![target file](./assets/target-file.png)
![target type](./assets/target-type.png)

## Installing the plugin

If you haven't downloaded our plugin yet, you can go ahead and download the latest release from our [plugin's Github repository](https://github.com/Raidflux/raidflux-unreal-engine/releases/latest). Extract the plugin in the Plugins folder of your project as shown below. The Plugins folder should be located on the root of your project, if it does not exist, you can create it.

![plugins dir](./assets/plugins-dir.png)

After that, right click the project and select "Generate Visual Studio project files" as shown below

![generate sln](./assets/generate-sln.png)

You can now open the newly generated .sln file and start your development editor by pressing the "f5" key on your keyboard.

## Integrating the server side

:::important
Make sure to only call the serverside functions on the server by checking [```IsDedicatedServer```](https://docs.unrealengine.com/4.26/en-US/API/Runtime/Engine/Kismet/UKismetSystemLibrary/IsDedicatedServer/) function.
:::

For the server side of Raidflux there are 2 functions that need to be called. The Raidflux plugin is integrated as a subsystem and is accessible wherever you have access to the ```UGameInstance```. 

import {UETabs, CPPTab, BPTab} from "@site/src/components/CustomTabs/UETabs.js"

<UETabs>
  <CPPTab>
{`#include "Raidflux.h"
...  
URaidflux::GetInstance(GetGameInstance());`}
  </CPPTab>
  <BPTab>
    <img src={require('./assets/raidflux-subsystem-node.png').default} alt="subsystem node"/>
  </BPTab>
</UETabs>

Whenever you start listening for incoming connections, you will need to call the ```URaidflux::Init``` function.

:::tip
In our demo project and we simply call the ```URaidflux::Init``` function in the ```BeginPlay``` event.
:::

:::important
You might see some cUrl errors in the output log, this is normal. This is because the init and report API's are only available when deployed in Raidflux's infrastructure.
:::

<UETabs>
  <CPPTab>
{`void ARaidfluxDemoGameMode::BeginPlay()
{
	Super::BeginPlay();
   
	if (UKismetSystemLibrary::IsDedicatedServer(GetWorld())) {
		FRaidfluxOnCompleted onCompletedInit;
		URaidflux::GetInstance(GetGameInstance())->Init(this->maxPlayers, onCompletedInit);
		onCompletedInit.BindDynamic(this, &ARaidfluxDemoGameMode::OnRaidfluxInitialized);
	}
	...
}`}
  </CPPTab>
  <BPTab>
    <img src={require('./assets/initialize-raidflux.png').default} alt="init raidflux"/>
  </BPTab>
</UETabs>

After initializing Raidflux, you will have to update the player count of your server every time a player joins or leaves. We accomplished this in our demo game by implementing the ```AGameMode::PostLogin``` and ```AGameMode::Logout``` events and passing the value of ```AGameMode::GetNumPlayers```.

<UETabs>
  <CPPTab>
{`void ARaidfluxDemoGameMode::PostLogin(APlayerController* NewPlayer)
{
	Super::PostLogin(NewPlayer)
 
	if (UKismetSystemLibrary::IsDedicatedServer(GetWorld())) {
		FRaidfluxOnCompleted onCompletedReport;
		URaidflux::GetInstance(GetGameInstance())->ReportPlayerCount(GetNumPlayers(), this->maxPlayers, onCompletedReport);
		onCompletedReport.BindDynamic(this, &ARaidfluxDemoGameMode::OnPlayerCountReported);
	}
}
 
void ARaidfluxDemoGameMode::Logout(AController* Exiting)
{
	Super::Logout(Exiting)
 
	if (UKismetSystemLibrary::IsDedicatedServer(GetWorld())) {
		FRaidfluxOnCompleted onCompletedReport;
		// Subtract 1 player because it has not been removed from the player controller list yet (it will be next frame).
		URaidflux::GetInstance(GetGameInstance())->ReportPlayerCount(GetNumPlayers() - 1, this->maxPlayers, onCompletedReport);
		onCompletedReport.BindDynamic(this, &ARaidfluxDemoGameMode::OnPlayerCountReported);
	}
}`}
  </CPPTab>
  <BPTab>
    <img src={require('./assets/report-count.png').default} alt="report player count"/>
  </BPTab>
</UETabs>

## Integrating the client side

For the client side of Raidflux there are 2 functions that need to be called. The Raidflux plugin is integrated as a subsystem and is accessible wherever you have access to the ```UGameInstance```.

<UETabs>
  <CPPTab>
{`#include "Raidflux.h"
...  
URaidflux::GetInstance(GetGameInstance());`}
  </CPPTab>
  <BPTab>
    <img src={require('./assets/raidflux-subsystem-node.png').default} alt="subsystem node"/>
  </BPTab>
</UETabs>

The client side of Raidflux is able to fetch motherships and their fleetships's gameservers. You can use these to join available gameservers.


